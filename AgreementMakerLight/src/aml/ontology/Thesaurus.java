/******************************************************************************
* Copyright 2013-2016 LASIGE                                                  *
*                                                                             *
* Licensed under the Apache License, Version 2.0 (the "License"); you may     *
* not use this file except in compliance with the License. You may obtain a   *
* copy of the License at http://www.apache.org/licenses/LICENSE-2.0           *
*                                                                             *
* Unless required by applicable law or agreed to in writing, software         *
* distributed under the License is distributed on an "AS IS" BASIS,           *
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    *
* See the License for the specific language governing permissions and         *
* limitations under the License.                                              *
*                                                                             *
*******************************************************************************
* A thesaurus based on one or more ontologies that derives synonym concepts   *
* from defined synonym names for ontology classes, and can use those synonyms *
* to extend ontology Lexicons.                                                *
*                                                                             *
* @authors Catia Pesquita, Daniel Faria                                       *
******************************************************************************/
package aml.ontology;

import java.util.Iterator;
import java.util.Set;
import java.util.Vector;

import aml.settings.LexicalType;
import aml.util.StringParser;
import aml.util.Table2List;

public class Thesaurus implements Iterable<String>
{
	
//Attributes
	
	//The Thesaurus of synonym words (String,String)
	public Table2List<String,String> thesaurus;
	//The confidence factor of this LexiconExtender
	private final double CONFIDENCE = 0.9;
	//The type of lexical entry generated by this LexiconExtender
	private static final LexicalType TYPE = LexicalType.INTERNAL_SYNONYM;
	
//Constructors
	
	/**
	 * Constructs a new empty Thesaurus
	 */
	public Thesaurus()
	{
		thesaurus = new Table2List<String,String>();
	}

	/**
	 * Constructs a new Thesaurus from a given Ontology
	 * @param lex
	 */
	public Thesaurus(Ontology o)
	{
		thesaurus = new Table2List<String,String>();
		buildFrom(o);
	}

//Public Methods
	
	/**
	 * Adds an entry to the Thesaurus between the given pair of synonyms
	 * @param s1: the first synonym to add to the Thesaurus
	 * @param s2: the second synonym to add to the Thesaurus
	 */
	public void add(String s1, String s2)
	{
		thesaurus.add(s1, s2);
		thesaurus.add(s2, s1);
	}

	/**
	 * Builds or extends the Thesaurus from the Lexicon of the given Ontology
	 * @param o: the Ontology to use to build the Thesaurus
	 */
	public void buildFrom(Ontology o)
	{
		Lexicon lex = o.getLexicon();
		Set<Integer> terms = lex.getClasses();
		//For each term in the Lexicon
		for(Integer i : terms)
		{
			//Compute synonym terms from its names
			addSynonymTerms(lex.getNames(i));
		}
	}
	
	/**
	 * Extends the Lexicon of the given Ontology using this Thesaurus
	 * @param o: the Ontology to extend
	 */
	public void extendLexicon(Ontology o)
	{
		Lexicon lex = o.getLexicon();
		Set<String> names = lex.getNames();
		//For each name in the Lexicon
		for(String n: names)
		{
			//If it is a formula, skip to the next name
			if(StringParser.isFormula(n))
				continue;
			//Otherwise, for each entry in the Thesaurus
			for(String s: this)
			{
				//If the entry is not contained in the name, skip to next entry
				if(!n.contains(s))
					continue;
				//Otherwise, get the Thesaurus synonyms for that entry
				Vector<String> thesEntries = get(s);
				//For each Thesaurus synonym, create a new synonym in the Lexicon
				Set<Integer> terms = lex.getInternalClasses(n);
				for(String t: thesEntries)
				{
					String newName = n.replace(s,t);
					for(Integer i: terms)
					{
						double weight = lex.getWeight(n,i) * CONFIDENCE;
						lex.addClass(i, newName, TYPE, "", weight);
					}
				}
			}
		}
	}

	/**
	 * @param n: the name to search in the Thesaurus
	 * @return the list of synonyms for the given name
	 */
	public Vector<String> get(String n)
	{
		return thesaurus.get(n);
	}

	@Override
	public Iterator<String> iterator()
	{
		return thesaurus.keySet().iterator();
	}

//Private Methods
	
	//Adds entries to the Thesaurus based on a set of names for a concept
	private void addSynonymTerms(Set<String> names)
	{
		//Compare the set of names pairwise
		String[] namesarray = names.toArray(new String[0]);
		for(int i = 0; i < namesarray.length; i++)
			for (int j = i; j < namesarray.length; j++)
				compareSynonyms(namesarray[i], namesarray[j]);
	}

	//Extracts subconcept synonyms from two given synonyms
	private void compareSynonyms(String synonym1, String synonym2)
	{
		//Step 0. Check if either synonym is a formula, and if so, return
		if(StringParser.isFormula(synonym1) || StringParser.isFormula(synonym2))
			return;
			
		//Step 1. Setup
		//Split the synonyms
		String[] words1 = synonym1.split(" ");
		String[] words2 = synonym2.split(" ");
		//Determine which synonym has more words, to simplify the algorithm
		String[] longerWords;
		String[] shorterWords;
		if( words1.length > words2.length )
		{
			longerWords = words1;
			shorterWords = words2;
		}
		else
		{
			longerWords = words2;
			shorterWords = words1;
		}

		//Step 2a. Determine the largest overlap between the two synonyms, starting from the end
		int distanceFromEnd;
		int lSize = longerWords.length - 1;
		int sSize = shorterWords.length - 1;
		for(distanceFromEnd = 0; distanceFromEnd < shorterWords.length; distanceFromEnd++)
		{
			 //If the word is a match, continue to the next word
			if(shorterWords[sSize - distanceFromEnd].equalsIgnoreCase(longerWords[lSize - distanceFromEnd]))
				continue;
			//Otherwise finish
			else
				break; 
		}
		
		//Step 2b. Refine the word range by checking for overlap at the beginning of the synonyms
		int distanceFromBeginning;
		for(distanceFromBeginning = 0; distanceFromBeginning < (longerWords.length - distanceFromEnd);
				distanceFromBeginning++ )
		{
			if(distanceFromBeginning >= shorterWords.length)
				return;
			if(shorterWords[distanceFromBeginning].equalsIgnoreCase(longerWords[distanceFromBeginning]))
				continue;
			else
				break;
		}

		//Step 3.  Identify the subconcept synonyms that we have found.
		int startIndex = distanceFromBeginning;
		int longerEndIndex = lSize - distanceFromEnd;
		int shorterEndIndex = sSize - distanceFromEnd;
		//If there is no correspondence between words, return
		//(e.g., in "facial vii motor nucleus" vs. "facial vii nucleus", motor has no correspondence)
		if(longerEndIndex < startIndex || shorterEndIndex < startIndex)
			return;
		//Create the longer synonym string;
		String longerSynonym = new String();
		for(int i = startIndex; i <= longerEndIndex; i++)
			longerSynonym += longerWords[i] + " ";
		longerSynonym = longerSynonym.trim();
		//Create the shorter synonym string
		String shorterSynonym = new String();
		for(int i = startIndex; i <= shorterEndIndex; i++)
			shorterSynonym += shorterWords[i] + " ";
		shorterSynonym = shorterSynonym.trim();
		add(shorterSynonym, longerSynonym);
		add(longerSynonym, shorterSynonym);
	}
}